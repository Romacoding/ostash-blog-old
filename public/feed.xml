<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><atom:link href="https://ostash.dev/" rel="self" type="application/rss+xml"/><title>Roman Ostash's personal blog</title><link>https://ostash.dev/</link><description>Code is a poetry</description><lastBuildDate>Sat, 23 May 2020 20:49:41 -0400</lastBuildDate><generator>clj-rss</generator><item><guid>https://ostash.dev/posts-output/2020-05-20-fifth-post/</guid><link>https://ostash.dev/posts-output/2020-05-20-fifth-post/</link><title>Functional programming explained. Higher order functions</title><description>&lt;blockquote&gt;&lt;p&gt;     If debugging is the process of removing software bugs, then programming must be the process of putting them in. - Edsger Dijkstra &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;div style="text-align: justify"&gt; What is a &lt;strong&gt;higher order function(HOF)&lt;/strong&gt;?  If a function receives as its input one or more functions or/and returns the function we can called it HOF. On the contrary, a single order function does not receive the function as an input. Functions that are passed as an argument to another function are what we refer to as &lt;strong&gt;callback functions.&lt;/strong&gt; Functions in JavaScript are variadic, that means that you can pass more or less arguments then is specified to the function and it still will run.&lt;br/&gt;  You as a &lt;strong&gt;functional programmer&lt;/strong&gt; should be comfortable making your own higher order functions. When you see two pieces that are not completely fit together you should be able to write an adapter/utility function to make them work jointly.&lt;br/&gt; We can take function that expects multiple parameters and reduce it shape to receive only one parameter, unary. Function that has one shape can be adapted to have another one. An example could be a "flip" HOF that receives another function, flips its parameters and returns it with parameters flipped. Another possible implementation would a "reverse" HOF that receives a function, reverse its parameters, and returns it with parameters reversed.&lt;br/&gt;  It is a good practice to get yourself familiar with existing functional programming libraries and tools and use patterns that are familiar to a larger community of programmers. That helps readability of your code. But when you can’t, make your own, document it well and make it available to others to use. &lt;/div&gt;&lt;/p&gt;</description><pubDate>Wed, 20 May 2020 00:00:00 -0400</pubDate></item><item><guid>https://ostash.dev/posts-output/2020-05-17-forth-post/</guid><link>https://ostash.dev/posts-output/2020-05-17-forth-post/</link><title>Functional programming explained. Currying</title><description>&lt;blockquote&gt;&lt;p&gt;     Don’t worry if it doesn’t work right.  If everything did, you’d be out of a job. - Mosher’s Law of Software Engineering &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;div style="text-align: justify"&gt; &lt;strong&gt;Currying&lt;/strong&gt; is an act of taking one function that receives more than one argument and refactoring it so it becomes &lt;strong&gt;HOF&lt;/strong&gt;(a higher order function) that returns series of functions each accepting only one argument and only evaluating once we receive our final argument.&lt;br/&gt;  The act of currying can be described as taking a multiary function and turning it into series of unary functions. Currying allows you to take an existing function that has one shape and &lt;strong&gt;specialize&lt;/strong&gt; it in producing a new function that is more adapted to your needs and has a shape that you want.&lt;br/&gt;  Functional programmers want everything to be currying because they like all functions to be &lt;strong&gt;unary&lt;/strong&gt;, single input single output. All functional libraries methods that you will encounter are automatically doing currying under the hood.&lt;br/&gt;  &lt;strong&gt;Partial application&lt;/strong&gt; and &lt;strong&gt;currying&lt;/strong&gt; are accomplishing the same thing but doing it in a different way. Partial application &lt;strong&gt;presets&lt;/strong&gt; some arguments now, receives the rest on the next call. Currying doesn't preset any arguments and receives each argument one at a time.&lt;br/&gt; There are some cases when it would be more preferable to do a partial application. Ex. a function expects 5 inputs and you want to produce another function with 3 inputs, so you want to preset 2 inputs. If you want to curry it, you would have to call it twice and the function you will receive in return would not be a function that expects  3 inputs, it would be a currying function of three more chains and it might not be the shape you want. In this case a partial application would be more preferable. &lt;/div&gt;&lt;/p&gt;</description><pubDate>Sun, 17 May 2020 00:00:00 -0400</pubDate></item><item><guid>https://ostash.dev/posts-output/2020-05-15-third-post/</guid><link>https://ostash.dev/posts-output/2020-05-15-third-post/</link><title>Functional programming explained. Arity</title><description>&lt;blockquote&gt;&lt;p&gt;     A good programmer is someone who always looks both ways before crossing a one-way street. - Doug Linder &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;div style="text-align: justify"&gt; Before we explain what arity is, let’s make a clear distinction between parameters and arguments in a function.  The &lt;strong&gt;parameter&lt;/strong&gt; is a variable declared in the function expression. It is a placeholder that is used to access function input (argument). The &lt;strong&gt;argument&lt;/strong&gt;, on the other hand is the actual value passed to a function when the function is called. We can say that function defines parameters and it takes arguments. &lt;strong&gt;Arity&lt;/strong&gt; describes how many arguments the function receives. The more inputs (parameters) the function has, the harder it is for the function to work with other functions.  Unary function takes one input and return one output, binary  - two inputs, ternary – three, quaternary – four and so forth (multiary - more than two inputs). Functional programmers tent to prefer &lt;strong&gt;unary functions&lt;/strong&gt; – single, input single output. &lt;/div&gt;&lt;/p&gt;</description><pubDate>Fri, 15 May 2020 00:00:00 -0400</pubDate></item><item><guid>https://ostash.dev/posts-output/2020-05-11-second-post/</guid><link>https://ostash.dev/posts-output/2020-05-11-second-post/</link><title>Functional programming explained. Functional purity</title><description>&lt;blockquote&gt;&lt;p&gt;     Object oriented programming makes code understandable by encapsulating moving parts. Functional programming makes code understandable by minimizing moving parts. – Michael Feathers &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;div style="text-align: justify"&gt; What is a function? For the function to be a function it has to return something, otherwise is a procedure. &lt;strong&gt;Function&lt;/strong&gt; is a semantic relationship between input and computed output.&lt;br/&gt; &lt;strong&gt;Pure function&lt;/strong&gt; is a function that derives its output solely from inputs and causes no &lt;strong&gt;side effects&lt;/strong&gt; in application or outside world. In a JavaScript we cannot completely sure if a function is pure unless we look on how the function was called.&lt;br/&gt; Every time we execute the pure function with same &lt;strong&gt;inputs&lt;/strong&gt; we absolutely and positively know that it will always return the same &lt;strong&gt;output&lt;/strong&gt;. We want our function calls to behave as pure: every time we give it a same input we expect to receive the same output. The function call needs to avoid using side effects.&lt;br/&gt; &lt;strong&gt;Impurity&lt;/strong&gt; is about side effects. Minimize them. They impurify functional programming. Avoid them where possible or make them obvious in your code. How, you would ask? By taking away the impurity and writing a pure function that does computations and then a procedure to do the rest.&lt;br/&gt; The degree of &lt;strong&gt;functional purity&lt;/strong&gt; in JavaScript shows in how confident a programmer is in function’s behavior. Higher degree of confidence relates to the higher level of purity in the function.&lt;br/&gt; Making pure functions might not always be possible or practical but we should strive to &lt;strong&gt;extract impurity&lt;/strong&gt; (side effects) and leave functions as pure. It is possible that for whatever reason we cannot change or modify the impure function. Another option would be to &lt;strong&gt;contain the impurity&lt;/strong&gt; so it doesn’t leek out to the rest of the scope.&lt;br/&gt; We can do that by &lt;strong&gt;wrapping&lt;/strong&gt; an impure function inside a pure function. By doing that we reduce the surface area of that impurity and improve the overall program readability and maintainability. &lt;/div&gt;&lt;/p&gt;</description><pubDate>Mon, 11 May 2020 00:00:00 -0400</pubDate></item><item><guid>https://ostash.dev/posts-output/2020-05-04-first-post/</guid><link>https://ostash.dev/posts-output/2020-05-04-first-post/</link><title>The beginning</title><description>&lt;h3 id="the&amp;#95;jorney&amp;#95;begins"&gt;The jorney begins&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt; A journey of a thousand miles begins with a single step.  – Lao Tzu &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;div style="text-align: justify"&gt; Like many of developers that were coding for the last few years, I was following mostly object oriented programming paradigm. Let’s not go into details on its specific implementation (hopefully the reader is familiar with it. If not, there are plenty of resources online to read upon this topic).&lt;br/&gt; With years passed you grow, you change, so as your code. In order to satisfy the need of learning, you are starting to look into other concepts, other programming styles and ideas. This blog will follow my journey of diving into the deep ocean of the functional programming. &lt;/div&gt;&lt;/p&gt;</description><pubDate>Mon, 04 May 2020 00:00:00 -0400</pubDate></item></channel></rss>