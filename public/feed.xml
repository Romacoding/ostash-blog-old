<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><atom:link href="https://ostash.dev/" rel="self" type="application/rss+xml"/><title>Roman Ostash's personal blog</title><link>https://ostash.dev/</link><description>Code is a poetry</description><lastBuildDate>Wed, 24 Jun 2020 12:14:34 -0400</lastBuildDate><generator>clj-rss</generator><item><guid>https://ostash.dev/posts-output/2020-05-30-seventh-post/</guid><link>https://ostash.dev/posts-output/2020-05-30-seventh-post/</link><title>Functional programming explained. Immutability</title><description>&lt;blockquote&gt;&lt;p&gt;     Why are we doing this? Because Clojure rocks, and JavaScript reaches. - Rich Hickey &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;div style="text-align: justify"&gt;  &lt;strong&gt;Mutable&lt;/strong&gt; data structure can be changed after creation &lt;strong&gt;immutable&lt;/strong&gt; cannot.&lt;br/&gt; Paradoxically, when you need to mutate a data structure, is a time then you should use an immutable data structure because it allows a structured mutation. Immutable data structure creates a controlled mechanism for the mutation to occur. &lt;strong&gt;Immutability&lt;/strong&gt; means, that you cannot change a data structure, you can only create a new data structure with changes applied to it.&lt;br/&gt; How that possibly be performant to create a whole new copy of the array or object every singe time we need to make changes? The immutable data structures are designed with the optimization in mind to mitigate that cost (a garbage collection and CPU load). When we use immutable data structures, the process of changing a property of the structure (mutation) is not to creature a whole new copy of that structure but to make a new structure with a new information in it and internally have a pointer to the previous one. It is similar to the git data structure: every time you commit something you just storing a difference compering to what it was before.&lt;br/&gt; We don’t have immutable data structures at the present time in JavaScript. There are library that provide us them like Immutable.js.  &lt;/div&gt;&lt;/p&gt;</description><pubDate>Sat, 30 May 2020 00:00:00 -0400</pubDate></item><item><guid>https://ostash.dev/posts-output/2020-05-25-sixth-post/</guid><link>https://ostash.dev/posts-output/2020-05-25-sixth-post/</link><title>Functional programming explained. A value mutability</title><description>&lt;blockquote&gt;&lt;p&gt;     Programming is like sex. One mistake and you have to support it for the rest of your life. - Michael Sinz &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;div style="text-align: justify"&gt;  &lt;strong&gt;Mutating a value&lt;/strong&gt;. When you receive a data structure that is in its identity &lt;strong&gt;mutable&lt;/strong&gt;, like an array or object, the best thing to do is to always assume that it is a read-only data structure and that you are not allowed to mutate it. Make a copy of the object/array (ex. spread operator) and then mutate it locally, so you don’t create a &lt;strong&gt;side effect&lt;/strong&gt; on the outside program.&lt;br/&gt; &lt;strong&gt;Preventing a value mutation&lt;/strong&gt;. If you are calling a function and you are going to pass to it a data structure like an array or object, make it clear to the reader that you don’t want it to be changed. Use something like Object.freeze method in JavaScript. Create a helper function that you can use to &lt;strong&gt;“freeze”&lt;/strong&gt; an object so no new properties can be added, changed or removed. &lt;/div&gt;&lt;/p&gt;</description><pubDate>Mon, 25 May 2020 00:00:00 -0400</pubDate></item><item><guid>https://ostash.dev/posts-output/2020-05-20-fifth-post/</guid><link>https://ostash.dev/posts-output/2020-05-20-fifth-post/</link><title>Functional programming explained. Higher order functions</title><description>&lt;blockquote&gt;&lt;p&gt;     If debugging is the process of removing software bugs, then programming must be the process of putting them in. - Edsger Dijkstra &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;div style="text-align: justify"&gt; What is a &lt;strong&gt;higher order function(HOF)&lt;/strong&gt;?  If a function receives as its input one or more functions or/and returns the function we can called it HOF. On the contrary, a single order function does not receive the function as an input. Functions that are passed as an argument to another function are what we refer to as &lt;strong&gt;callback functions.&lt;/strong&gt; Functions in JavaScript are variadic, that means that you can pass more or less arguments then is specified to the function and it still will run.&lt;br/&gt;  You as a &lt;strong&gt;functional programmer&lt;/strong&gt; should be comfortable making your own higher order functions. When you see two pieces that are not completely fit together you should be able to write an adapter/utility function to make them work jointly.&lt;br/&gt; We can take function that expects multiple parameters and reduce it shape to receive only one parameter, unary. Function that has one shape can be adapted to have another one. An example could be a "flip" HOF that receives another function, flips its parameters and returns it with parameters flipped. Another possible implementation would a "reverse" HOF that receives a function, reverse its parameters, and returns it with parameters reversed.&lt;br/&gt;  It is a good practice to get yourself familiar with existing functional programming libraries and tools and use patterns that are familiar to a larger community of programmers. That helps readability of your code. But when you can’t, make your own, document it well and make it available to others to use. &lt;/div&gt;&lt;/p&gt;</description><pubDate>Wed, 20 May 2020 00:00:00 -0400</pubDate></item><item><guid>https://ostash.dev/posts-output/2020-05-17-forth-post/</guid><link>https://ostash.dev/posts-output/2020-05-17-forth-post/</link><title>Functional programming explained. Currying</title><description>&lt;blockquote&gt;&lt;p&gt;     Don’t worry if it doesn’t work right.  If everything did, you’d be out of a job. - Mosher’s Law of Software Engineering &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;div style="text-align: justify"&gt; &lt;strong&gt;Currying&lt;/strong&gt; is an act of taking one function that receives more than one argument and refactoring it so it becomes &lt;strong&gt;HOF&lt;/strong&gt;(a higher order function) that returns series of functions each accepting only one argument and only evaluating once we receive our final argument.&lt;br/&gt;  The act of currying can be described as taking a multiary function and turning it into series of unary functions. Currying allows you to take an existing function that has one shape and &lt;strong&gt;specialize&lt;/strong&gt; it in producing a new function that is more adapted to your needs and has a shape that you want.&lt;br/&gt;  Functional programmers want everything to be currying because they like all functions to be &lt;strong&gt;unary&lt;/strong&gt;, single input single output. All functional libraries methods that you will encounter are automatically doing currying under the hood.&lt;br/&gt;  &lt;strong&gt;Partial application&lt;/strong&gt; and &lt;strong&gt;currying&lt;/strong&gt; are accomplishing the same thing but doing it in a different way. Partial application &lt;strong&gt;presets&lt;/strong&gt; some arguments now, receives the rest on the next call. Currying doesn't preset any arguments and receives each argument one at a time.&lt;br/&gt; There are some cases when it would be more preferable to do a partial application. Ex. a function expects 5 inputs and you want to produce another function with 3 inputs, so you want to preset 2 inputs. If you want to curry it, you would have to call it twice and the function you will receive in return would not be a function that expects  3 inputs, it would be a currying function of three more chains and it might not be the shape you want. In this case a partial application would be more preferable. &lt;/div&gt;&lt;/p&gt;</description><pubDate>Sun, 17 May 2020 00:00:00 -0400</pubDate></item><item><guid>https://ostash.dev/posts-output/2020-05-15-third-post/</guid><link>https://ostash.dev/posts-output/2020-05-15-third-post/</link><title>Functional programming explained. Arity</title><description>&lt;blockquote&gt;&lt;p&gt;     A good programmer is someone who always looks both ways before crossing a one-way street. - Doug Linder &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;div style="text-align: justify"&gt; Before we explain what arity is, let’s make a clear distinction between parameters and arguments in a function.  The &lt;strong&gt;parameter&lt;/strong&gt; is a variable declared in the function expression. It is a placeholder that is used to access function input (argument). The &lt;strong&gt;argument&lt;/strong&gt;, on the other hand is the actual value passed to a function when the function is called. We can say that function defines parameters and it takes arguments. &lt;strong&gt;Arity&lt;/strong&gt; describes how many arguments the function receives. The more inputs (parameters) the function has, the harder it is for the function to work with other functions.  Unary function takes one input and return one output, binary  - two inputs, ternary – three, quaternary – four and so forth (multiary - more than two inputs). Functional programmers tent to prefer &lt;strong&gt;unary functions&lt;/strong&gt; – single, input single output. &lt;/div&gt;&lt;/p&gt;</description><pubDate>Fri, 15 May 2020 00:00:00 -0400</pubDate></item><item><guid>https://ostash.dev/posts-output/2020-05-11-second-post/</guid><link>https://ostash.dev/posts-output/2020-05-11-second-post/</link><title>Functional programming explained. Functional purity</title><description>&lt;blockquote&gt;&lt;p&gt;     Object oriented programming makes code understandable by encapsulating moving parts. Functional programming makes code understandable by minimizing moving parts. – Michael Feathers &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;div style="text-align: justify"&gt; What is a function? For the function to be a function it has to return something, otherwise is a procedure. &lt;strong&gt;Function&lt;/strong&gt; is a semantic relationship between input and computed output.&lt;br/&gt; &lt;strong&gt;Pure function&lt;/strong&gt; is a function that derives its output solely from inputs and causes no &lt;strong&gt;side effects&lt;/strong&gt; in application or outside world. In a JavaScript we cannot completely sure if a function is pure unless we look on how the function was called.&lt;br/&gt; Every time we execute the pure function with same &lt;strong&gt;inputs&lt;/strong&gt; we absolutely and positively know that it will always return the same &lt;strong&gt;output&lt;/strong&gt;. We want our function calls to behave as pure: every time we give it a same input we expect to receive the same output. The function call needs to avoid using side effects.&lt;br/&gt; &lt;strong&gt;Impurity&lt;/strong&gt; is about side effects. Minimize them. They impurify functional programming. Avoid them where possible or make them obvious in your code. How, you would ask? By taking away the impurity and writing a pure function that does computations and then a procedure to do the rest.&lt;br/&gt; The degree of &lt;strong&gt;functional purity&lt;/strong&gt; in JavaScript shows in how confident a programmer is in function’s behavior. Higher degree of confidence relates to the higher level of purity in the function.&lt;br/&gt; Making pure functions might not always be possible or practical but we should strive to &lt;strong&gt;extract impurity&lt;/strong&gt; (side effects) and leave functions as pure. It is possible that for whatever reason we cannot change or modify the impure function. Another option would be to &lt;strong&gt;contain the impurity&lt;/strong&gt; so it doesn’t leek out to the rest of the scope.&lt;br/&gt; We can do that by &lt;strong&gt;wrapping&lt;/strong&gt; an impure function inside a pure function. By doing that we reduce the surface area of that impurity and improve the overall program readability and maintainability. &lt;/div&gt;&lt;/p&gt;</description><pubDate>Mon, 11 May 2020 00:00:00 -0400</pubDate></item><item><guid>https://ostash.dev/posts-output/2020-05-04-first-post/</guid><link>https://ostash.dev/posts-output/2020-05-04-first-post/</link><title>The beginning</title><description>&lt;h3 id="the&amp;#95;jorney&amp;#95;begins"&gt;The jorney begins&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt; A journey of a thousand miles begins with a single step.  – Lao Tzu &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;div style="text-align: justify"&gt; Like many of developers that were coding for the last few years, I was following mostly object oriented programming paradigm. Let’s not go into details on its specific implementation (hopefully the reader is familiar with it. If not, there are plenty of resources online to read upon this topic).&lt;br/&gt; With years passed you grow, you change, so as your code. In order to satisfy the need of learning, you are starting to look into other concepts, other programming styles and ideas. This blog will follow my journey of diving into the deep ocean of the functional programming. &lt;/div&gt;&lt;/p&gt;</description><pubDate>Mon, 04 May 2020 00:00:00 -0400</pubDate></item></channel></rss>